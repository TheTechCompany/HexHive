{"version":3,"sources":["../../src/symbols.js","../../src/element.js","../../src/internals/context.js","../../src/internals/error.js","../../src/internals/state.js","../../src/internals/objectIs.js","../../src/internals/dispatcher.js","../../src/render/lazyComponent.js","../../src/render/functionComponent.js","../../src/render/classComponent.js","../../src/visitor.js","../../src/index.js","../node_modules/timers-browserify/main.js","../node_modules/setimmediate/setImmediate.js"],"names":["this","let","ConcurrentMode","ForwardRef","Suspense","Memo","Lazy","Symbol","symbolFor","const","REACT_ELEMENT_TYPE","Element","REACT_PORTAL_TYPE","Portal","REACT_FRAGMENT_TYPE","Fragment","REACT_STRICT_MODE_TYPE","StrictMode","REACT_PROFILER_TYPE","Profiler","REACT_PROVIDER_TYPE","ContextProvider","REACT_CONTEXT_TYPE","ContextConsumer","REACT_CONCURRENT_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","toArray","Children","node","isAbstractElement","props","defaultProps","Object","currentContextStore","Map","currentContextMap","prevContextMap","prevContextEntry","prev","map","store","context","value","emptyContext","type","contextType","contextTypes","name","maskedContext","currentErrorFrame","rendererStateRef","current","uniqueID","objectIs","x","y","currentIdentity","firstWorkInProgressHook","workInProgressHook","didScheduleRenderPhaseUpdate","renderPhaseUpdates","numberOfReRenders","createWorkInProgressHook","memoizedState","queue","next","basicStateReducer","state","action","useReducer","reducer","initialArg","init","id","getCurrentIdentity","initialState","last","dispatch","dispatchAction","firstRenderPhaseUpdate","newState","update","useMemo","nextCreate","deps","prevState","nextDeps","a","prevDeps","i","is","areHookInputsEqual","nextValue","componentIdentity","lastRenderPhaseUpdate","noop","callback","Dispatcher","readContext","useContext","useRef","initialValue","previousRef","ref","useState","useCallback","useMutableSource","source","getSnapshot","useTransition","useDeferredValue","input","useOpaqueIdentifier","useLayoutEffect","useImperativeHandle","useEffect","useDebugValue","payload","Component","error","createElement","thenable","contextMap","contextStore","hook","kind","errorFrame","computeProps","maskContext","children","refOrContext","RE_RENDER_LIMIT$1","makeFrame","instance","nextState","l","partial","partialState","child","childContext","_err","ReactCurrentDispatcher","React","SHOULD_YIELD","element","visitor","getChildrenArray","readContextValue","lazyElement","resolve","render","shouldConstruct","updater","_thrown","isMounted","enqueueForceUpdate","enqueueReplaceState","completeState","enqueueSetState","currentPartialState","computedProps","mountClassComponent","frame","promise","mountFunctionComponent","traversalChildren","traversalMap","traversalStore","traversalErrorFrame","prevDispatcher","start","Date","visitElement","flushPrevContextMap","flushPrevContextStore","YIELD_AFTER_MS","makeYieldFrame","setCurrentContextMap","setCurrentContextStore","visitLoop","RE_RENDER_LIMIT","visit","setImmediate","Promise","e","flushFrames","scope","global","self","window","apply","Function","prototype","Timeout","clearFn","_id","_clearFn","exports","setTimeout","call","arguments","clearTimeout","setInterval","clearInterval","timeout","close","unref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","require","clearImmediate","undefined","registerImmediate","nextHandle","tasksByHandle","currentlyRunningATask","doc","document","attachTo","getPrototypeOf","toString","process","handle","nextTick","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","messagePrefix","Math","random","onGlobalMessage","event","data","indexOf","slice","length","addEventListener","attachEvent","installPostMessageImplementation","MessageChannel","channel","port1","port2","installMessageChannelImplementation","html","documentElement","script","onreadystatechange","removeChild","appendChild","installReadyStateChangeImplementation","args","Array","task","run"],"mappings":"oWAKaA,KADbC,W,sBAMsB,MAClBC,EAAiB,MACjBC,EAAa,MACbC,EAAW,MACXC,EAAO,MACPC,EAAO,sC,GAEW,2BAAcC,OAAOA,IAAK,C,IACxCC,EAAYD,OAAOA,I,EACfC,EAAU,iB,EACXA,EAAU,gB,EACRA,EAAU,kB,EACRA,EAAU,qB,EACZA,EAAU,kB,EACHA,EAAU,kB,EACVA,EAAU,iB,EACXD,OAAOA,IAAI,yB,EACfC,EAAU,qB,EACZA,EAAU,kB,EACdA,EAAU,c,EACVA,EAAU,cAkBZC,IAAMC,EAAuCC,EACvCC,EAAqCC,EACrCC,EAAyCC,EACzCC,EAA+CC,EAC/CC,EAAyCC,EACzCC,EAAyCC,EACzCC,EAAuCC,EACvCC,EAAuDtB,EACvDuB,EAA+CtB,EAC/CuB,EAAyCtB,EACzCuB,EAAiCtB,EACjCuB,EAAiCtB,ECUxCuB,EACJC,mB,WAIAC,G,cACoBA,GAAiC,mB,WAGtBA,G,SAEhBA,UAAaC,G,WAIDC,EAAeC,G,MACX,mBAC3BC,EAAc,GAAID,EAAcD,GAChCA,ECnENhC,IAAImC,EAAoC,IAAIC,IACxCC,EAAgC,GAEhCC,SACAC,S,iBAQIC,EAAOF,E,mCAMPE,EAAOD,E,6BAiBsBE,GACnCH,S,EACoBG,E,WAGiBC,GACrCH,S,EACsBG,E,WAgBSC,G,IACzBC,EAAQT,MAAwBQ,G,gBAClCC,EACKA,EAIFD,gBAGTnC,IAAMqC,EAAe,G,WAEOC,G,wCAGtBC,E,SACsBA,G,IACdC,E,aAKPxC,IAAMyC,K,EADW,GACXA,EACTC,EAAcD,GAAQZ,EAAkBY,G,SChG5CjD,IAAImD,EAAuC,KCA9BC,EAAiD,CAC5DC,QAAS,CAAEC,SAAU,ICajBC,EACiB,6BAAarB,OAAOA,GAAPA,SAPxBsB,EAAQC,G,WAETA,IAAY,IAAND,GAAW,EAAIA,GAAM,EAAIC,IAAQD,GAAMA,GAAKC,GAAMA,GCO/DC,EAAmC,K,gBASb,OAApBA,E,YAEA,iI,SAYN1D,IAAI2D,EAAuC,KACvCC,EAAkC,KAElCC,KAEAC,GAAgE,KAEhEC,GAA4B,EAgChCC,SAASA,K,cACHJ,EAE8B,OAA5BD,EACMA,EAA0BC,EAX/B,CACLK,cAAe,KACfC,MAAO,KACPC,KAAM,MAWIP,EAAqBD,EAKrBC,EAFsB,OAA5BA,OAE2BA,OAnB1B,CACLK,cAAe,KACfC,MAAO,KACPC,KAAM,MAmByBP,OAiDnCQ,SAASA,GAAqBC,EAAUC,G,MAEb,qBAAaA,EAAOD,GAASC,EAaxDC,SAASA,GACPC,EACAC,EACAC,G,IAEMC,EAAKC,I,aACUZ,cASjBa,EAFEL,IAAYJ,GAGU,qBAChBK,IACAA,WAGNC,EAAqBA,EAAKD,GAAgBA,EAG9Cb,gBAAmCiB,G,KAInCjB,UACCA,QAA2B,CAAEkB,KAAM,KAAMC,SAAU,Q,WAEjCb,WAAiBc,QAAoB,KAAML,EAAIT,IAEzC,OAAvBJ,cAIImB,EAAyBnB,OAAuBI,IACZ,CACxCJ,UAA0BI,G,EACXN,gB,KAOFY,EAAQU,EADJC,UAEfA,EAASA,aACS,OAAXA,G,gBAE0BD,E,MAIhC,CAACtB,gBAAkCmB,GAG5CK,SAASA,GAAWC,EAAqBC,GACvCV,I,WAGiBU,EAAqB,KAAOA,E,IACvCC,KAHevB,oB,GAIH,OAAduB,GAAmC,OAAbC,EAAmB,CAnK7CC,GAqKmCC,MADhBH,EAAU,G,GAjKZ,OAAbG,E,cAEC1F,IAAI2F,EAAI,EAAGA,EAAID,UAAmBC,EAgKdH,SAhKmCG,I,IACrDC,EA+JkBJ,EA/JNG,GAAID,EAASC,K,sBA+J1BE,E,SACe,G,OAIfC,EAAYT,I,gBACiB,CAACS,EAAWN,G,EA0BjDR,SAASA,GACPe,EACA7B,EACAI,G,GAEIyB,IAAsBrC,E,GAIxBG,KACMsB,EAAoB,C,OACxBb,EACAH,KAAM,MAEmB,OAAvBL,KACFA,GAAqB,IAAI1B,eAErB6C,EAAyBnB,OAAuBI,IAEpDJ,OAAuBI,EAAOiB,OACzB,C,IAEDa,EAAwBf,EACU,OAA/Be,QACLA,EAAwBA,O,OAEGb,GAsBnCc,SAASA,M,YAGkBC,GACvBA,IASG1F,IAAM2F,GAAa,C,YA1L1BC,SAAqBzD,G,SAIKA,I,WAG1B0D,SAAoB1D,G,OAClBiC,I,EACwBjC,I,QAoLxByC,G,WACAb,G,OAvFF+B,SAAmBC,GACjB3B,I,IAEM4B,KADexC,oB,cAEjBwC,EAEF5C,gBADM6C,EAAM,CAAEpD,QAASkD,GAIhBC,G,SA/FXE,SACE7B,G,UAGET,GAECS,I,YAyIL8B,SAAwBT,EAAaZ,G,iCACJA,I,iBAGjCsB,SACEC,EACAC,G,OAGAlC,I,EACmBiC,Y,cAKrBE,W,MAIS,CAAC,IAAD,I,iBAGTC,SAA6BC,G,8BAlE7BC,W,OACEtC,K,EACqBZ,sBAEnBJ,gBACE,MAAQR,+BAA8C,K,iBA+E1D+D,gBAAiBlB,GAEjBmB,oBAAqBnB,GAErBoB,UAAWpB,GAEXqB,cAAerB,I,YChUAnD,G,IACTyE,EAAWzE,YAAiBA,E,OACV,IAApByE,U,UAE2B,IAApBA,U,gBACcA,WACM,IAApBA,U,eACaA,Y,UAGN,E,WAESA,SAAiBA,4BACnCC,GACLD,UAAkBC,E,qBAEhBD,UAAkB,EAEJ,OAAdC,GACqB,oBACQ,8BAE7BD,UAAkBC,UAClBD,UAAkB,GAElBA,UAAkB,K,gBAGdE,G,OACNF,UAAkB,E,UACAE,E,eACIA,O,YAK1B3E,EACAd,G,YAKMuF,EAAYzE,YAAiBA,WAE1B4E,wBAAcH,UAAiBvF,GAGjC,K,YCpCPc,EACAd,EACA2F,G,MACI,CACJC,WNVA1F,EAAc,GAAIG,GMWlBwF,aNTA,IAAIzF,IAAID,GMURwC,GAAIC,IACJkD,KFe6CnE,EEd7CoE,KAAM,cACNC,WLnC2D7E,E,SKoC3DwE,E,MACA3F,E,KACAc,G,YAIAA,EACAd,EACAkC,G,IAKI+D,QAAajG,EAAOc,gBACpBoF,IAAYpF,G,EFoDK,K,QACjBqF,EEvDArF,EFuDqBd,EAAOoG,GAzDVC,GA6DftE,IAAuCF,GAK5CA,KACAE,IAAqB,EAErBH,EAAqB,KACrBuE,EEpEErF,EFoEmBd,EAAOoG,G,UAMV,E,EACpBtE,GAAqB,K,EEvEnB,MAAO2D,G,GACmB,0B,eAI1BvD,OAAWoE,GAAUxF,EAAMd,EAAOyF,I,mECgDpC3E,EACAyF,EACAZ,G,MACI,CACJC,WPzFA1F,EAAc,GAAIG,GO0FlBwF,aPxFA,IAAIzF,IAAID,GOyFR6F,WN/G2D7E,E,SMgH3DwE,EACAI,KAAM,cACNN,MAAO,K,SACPc,E,KACAzF,G,YAGcA,EAAWyF,EAAerE,G,IA3ElCA,EA6EaqE,gB,GA3EA,EAAfrE,SAAkB,C,QAChBsE,EAAYtG,EAAc,GA0EbqG,SAxER5C,EAAI,EAAG8C,EAAIvE,SAAcyB,EAAI8C,EAAG9C,IAAK,C,IACtC+C,EAAUxE,EAAMyB,G,UAED,qBACf+C,OAoESH,EApEcC,EAoEdD,mBAnETG,MAEUF,EAAWG,GAiEZJ,QA7DAC,E,SACF,EA6DbI,EAAc,K,IAGhBA,EAAQL,WACR,MAAOd,G,GACmB,0B,eAI1BvD,OAAWoE,GAAUxF,EAAMyF,EAAUd,I,iBAKrC3E,qBACoC,sCAGf,QADf+F,EAAeN,sBACgC,mB,IPhFlD/H,IAAMyC,KADXX,EAAiB,GACNW,EACTX,EAAeW,GAAQZ,EAAkBY,GACzCZ,EAAkBY,GO+EC4F,EP/EW5F,G,GOoFe,gDACL,yCACQ,iDACP,0C,IAGvCsF,yBACA,MAAOO,I,OAGXP,gB,ECzFAQ,OACGC,8EAKQC,GAAuC,qB,YAkBlDC,EACAhF,EACAiF,G,gBT1EqB3F,G,OACbA,Y,KACD7C,E,cAEAF,E,OACK+C,Q,KACDjC,E,cAEAV,E,cAEAI,E,cAEAF,E,cAEAU,E,wBAIK+B,QAAYA,iB,KACb7B,E,cAEAD,E,cAEAL,E,cAEAF,E,cAEAK,E,8BSiDA0H,I,KACRzH,E,KACAV,E,KACAQ,E,KACAN,E,KACAJ,E,SAEuBqI,kB,KAMvB/H,E,MACuB+H,Q,gCR1CX,CAAC,EQ0CUA,gBR1CD/G,MAAwBQ,I,MAC7BA,EAASC,G,EQ8CLuF,G,KAGrB9G,E,MAKqB,qBAJE6H,kBAQjBE,EAAiBjB,EADlBvF,EAAQyG,EAD2B,iBADnCvG,EALkBoG,iBAM4BpG,WAAgBA,KAI7D,G,KAINnB,E,SACmBuH,OAEiBI,EAFjBJ,QH7DH,IADLpG,YAAiBA,YGgE2BoB,OH9DjD,CACT6D,KAAM,aACNH,WLvDJ1F,EAAc,GAAIG,GKwDdwF,aLtDJ,IAAIzF,IAAID,GKuDJ6F,WJ7EuD7E,EI8EvDwE,SAAU4B,GAAQzG,G,MAClBd,E,KACAc,I,EAGK,QAGF0G,GAAO1G,EAAMd,GGkDToH,EAAiBR,G,KAGrBlH,E,OAII0H,IADO1B,wBAFQwB,sB,KAMnB1H,E,YACkB0H,eAEflH,EAAQiG,EAFOiB,wBAIdE,EADDR,EAAQlB,wBAAe5E,EAAYd,I,KAItCvB,E,GAEoB,wB,SADVyI,kB,IAOgBlH,EAFLkH,Q,MAAAA,mBA3ELpG,6BAAhB2G,CJjEP/F,EGoJmBiB,K,IAtGb+E,a,IA5CAxF,EAAQ,G,MAEP,CACLyF,QAAS,E,MACTzF,EACA0F,aACAC,sBACAC,6BAAsBvB,EAAUwB,GAC1BxB,eACFrE,SAAe,EACfA,OAAW6F,KAGfC,yBAAkBzB,EAAU0B,GACtB1B,cACFrE,OAAW+F,KA6BXP,GACAQ,EAAgBjC,ECmBlBkC,kBDlBExH,EAAUuF,ECkBZiC,I,EDjBa,ICiBbA,EDjBsBD,EAAevH,EAAS+G,UAEjCQ,E,UACEvH,E,UACA+G,E,yBAGfnB,UACFA,QAAiB,MAIqB,wCACG,gDAEnC6B,EAAQ9B,GCEZ6B,EDF4B5B,EAAU,MNjF1CpF,GMkFEiH,aAAmBA,INlFQ,M,8CMyFb,OADR/F,KCLJ8F,4BDKqC5B,QAAgBA,YAErDA,QAAiBrG,EAAc,GAAIqG,QAAgBlE,IAEL,wCAChDkE,uBACuD,gDACvDA,+BAyEI8B,ECrFFF,EA0EwBjB,ED3DrBX,KCfH4B,ODuFS7B,GCvFT6B,EDeG5B,EAwEgC8B,MAC9B,QAGFb,GC3FHW,EDeG5B,ECfH4B,Q,EFhBSrC,KFlDbpE,EAH2CiB,IEwDrC0F,EEcFC,EAyEwBpB,KAzExBoB,OFZShC,GEYTgC,IFZgCD,MAC3B,QAGFb,GEQHc,O,SAFGb,G,cAqFI,I,YAKXc,EACAC,EACAC,EACAC,EACAxG,EACAiF,G,IAEMwB,EAAiB5B,WACjB6B,EAAQC,KAAKA,M,QAGjB9B,WAAiC5C,GACC,EAA3BoE,UAA8B,C,IAC7BrB,EAAUqB,EAAkBA,SAA2B,W,YACzDrB,EAAuB,C,IACnBf,EAAW2C,GAAa5B,EAAShF,EAAOiF,G,OACvBhB,G,OACL4C,K,OACEC,K,OPjMiC7H,OOmMhD,CACLoH,Q,IACkBC,e,IRhKpBhI,KACYH,EAAmBG,G,IQgKTiI,e,IR3JtBjI,GACFL,MAAwBK,EAAK,GAAIA,EAAK,I,EQ2JbkI,SPpME,K,GOuMrBzB,IA9HagC,EA8HGJ,KAAKA,MAAQD,E,kBAMnC,MAAOnD,G,KACDO,EPjNmD7E,G,eOmNzD6E,QAAmBP,E,UACLO,I,UAGde,WAAiC4B,G,YAKnCJ,EACAC,EACAC,EACAC,G,MACW,CACX9C,WR7MA1F,EAAc,GAAIG,GQ8MlBwF,aR5MA,IAAIzF,IAAID,GQ6MR6F,WPnO2D7E,EOoO3DwE,SAAU,KACVI,KAAM,c,kBACNwC,E,aACAC,E,eACAC,E,oBACAC,G,YAIAhG,EACAR,EACAiF,GAEMoB,EAAyC,CAAC7F,G,IAC1C8F,EAAyC,CAACO,KAC1CN,EAA6C,CAACO,KAC9CN,EAAgD,CPpPKvH,G,GOuPzDoH,EACAC,EACAC,EACAC,EACAxG,EACAiF,IAIAjF,UACEgH,GACEX,EACAC,EACAC,EACAC,I,YAMeN,EAAclG,EAAgBiF,G,GAChC,gBAAfiB,OJxPJ1G,EIyPqBiB,KACnBwG,EAAqBf,cACrBgB,EAAuBhB,gBP5QzBjH,EO6QuBiH,cP7QM,KO+QRiB,GACjBjB,oBACAA,eACAA,iBACAA,sBACAlG,EACAiF,IAIAjF,UACEgH,GACEd,oBACAA,eACAA,iBACAA,4BAID,C,IACCO,EAAiB5B,WACnBZ,EAAW,K,WAEkBhC,G,OAGZ,gBAAfiE,ODvHmD3E,G,GHjK3D/B,EGkKmBiB,K,ECuH0ByF,c,EAAAA,gB,EAAAA,cP1ShB,KO0SgBA,QDlH5B,C,GAxKKkB,MC0RuBlB,4B,EDhHqB,K,QCgHrBA,yB,iDAAAA,sC,oDAAAA,wF,EDhGtCZ,GCgGsCY,kBAAPlG,OACR,gBAAfkG,QJ3PfzG,EI4PgDyG,OJ3RhD1G,EI2RgD0G,KFzNhDe,EEyNgDf,cFxNhDgB,EEwNgDhB,gBP5ShDjH,EO4SgDiH,cP5SnB,OKsFtBZ,GEsNyCY,eAAPlG,IACX,eAAfkG,SJ5Rf1G,ECsEmBiB,KACnBwG,EGsN4Cf,cHrN5CgB,EGqN4ChB,gBP9S5CjH,EO8S4CiH,cP9Sf,OI2FtBZ,GGmNqCY,iBAExC,MAAO3C,G,KACDO,EPpTiD7E,G,QOsTvD6E,QAAmBP,E,UACLO,G,EACH,K,QAEXe,WAAiC4B,EAGnCY,GAAMnC,EAAiBjB,GAAWjE,EAAOiF,I,YC7RXI,GAC5BiC,EAAajC,G,YAXjBrF,EACAiF,EACA9E,G,IAEM+F,EAAQlG,U,OACTkG,G,IAI8B,gBAAfA,SAClBA,WAAiB,IAAIqB,a,gBAKArB,6B,OPjCtBhH,UOmC2BiB,E,GACjB+F,EAAOlG,EAAOiF,G,GACFjF,EAAOiF,EAAS9E,M,SAEpCoD,G,IACM2C,a,QACLA,mBAAyB3C,E,GAClB2C,aAAkBlG,EAAOiF,O,+DAQ/BA,IAASA,sB,oBAUO,S,OR7DrBhG,I,KQiEIsC,GACF8F,EAAMnC,GAANmC,MACAG,G,qCAIKC,O,qDCjFT,gBAAIC,EAA2B,qBAAXC,GAA0BA,GACjB,qBAATC,MAAwBA,MAChCC,OACRC,EAAQC,SAASC,UAAUF,MAiB/B,SAASG,EAAQxH,EAAIyH,GACnBrM,KAAKsM,IAAM1H,EACX5E,KAAKuM,SAAWF,EAflBG,EAAQC,WAAa,WACnB,OAAO,IAAIL,EAAQH,EAAMS,KAAKD,WAAYZ,EAAOc,WAAYC,eAE/DJ,EAAQK,YAAc,WACpB,OAAO,IAAIT,EAAQH,EAAMS,KAAKG,YAAahB,EAAOc,WAAYG,gBAEhEN,EAAQI,aACRJ,EAAQM,cAAgB,SAASC,GAC3BA,GACFA,EAAQC,SAQZZ,EAAQD,UAAUc,MAAQb,EAAQD,UAAUzF,IAAM,aAClD0F,EAAQD,UAAUa,MAAQ,WACxBhN,KAAKuM,SAASG,KAAKb,EAAO7L,KAAKsM,MAIjCE,EAAQU,OAAS,SAASC,EAAMC,GAC9BR,aAAaO,EAAKE,gBAClBF,EAAKG,aAAeF,GAGtBZ,EAAQe,SAAW,SAASJ,GAC1BP,aAAaO,EAAKE,gBAClBF,EAAKG,cAAgB,GAGvBd,EAAQgB,aAAehB,EAAQiB,OAAS,SAASN,GAC/CP,aAAaO,EAAKE,gBAElB,IAAID,EAAQD,EAAKG,aACbF,GAAS,IACXD,EAAKE,eAAiBZ,YAAW,WAC3BU,EAAKO,YACPP,EAAKO,eACNN,KAKPO,EAAQ,KAIRnB,EAAQf,aAAgC,qBAATM,MAAwBA,KAAKN,cAClB,qBAAXK,GAA0BA,EAAOL,cACxCzL,MAAQA,KAAKyL,aACrCe,EAAQoB,eAAkC,qBAAT7B,MAAwBA,KAAK6B,gBAClB,qBAAX9B,GAA0BA,EAAO8B,gBACxC5N,MAAQA,KAAK4N,iB,uCC9DtC,wBAAU9B,EAAQ+B,GACf,aAEA,IAAI/B,EAAOL,aAAX,CAIA,IAIIqC,EAJAC,EAAa,EACbC,EAAgB,GAChBC,GAAwB,EACxBC,EAAMpC,EAAOqC,SAoJbC,EAAWjM,OAAOkM,gBAAkBlM,OAAOkM,eAAevC,GAC9DsC,EAAWA,GAAYA,EAAS3B,WAAa2B,EAAWtC,EAGf,qBAArC,GAAGwC,SAAS5B,KAAKZ,EAAOyC,SApFxBT,EAAoB,SAASU,GACzBD,EAAQE,UAAS,WAAcC,EAAaF,OAIpD,WAGI,GAAI1C,EAAO6C,cAAgB7C,EAAO8C,cAAe,CAC7C,IAAIC,GAA4B,EAC5BC,EAAehD,EAAOiD,UAM1B,OALAjD,EAAOiD,UAAY,WACfF,GAA4B,GAEhC/C,EAAO6C,YAAY,GAAI,KACvB7C,EAAOiD,UAAYD,EACZD,GAwEJG,GApEX,WAKI,IAAIC,EAAgB,gBAAkBC,KAAKC,SAAW,IAClDC,EAAkB,SAASC,GACvBA,EAAMvI,SAAWgF,GACK,kBAAfuD,EAAMC,MACyB,IAAtCD,EAAMC,KAAKC,QAAQN,IACnBP,GAAcW,EAAMC,KAAKE,MAAMP,EAAcQ,UAIjD3D,EAAO4D,iBACP5D,EAAO4D,iBAAiB,UAAWN,GAAiB,GAEpDtD,EAAO6D,YAAY,YAAaP,GAGpCtB,EAAoB,SAASU,GACzB1C,EAAO6C,YAAYM,EAAgBT,EAAQ,MAiD/CoB,GAEO9D,EAAO+D,eA/ClB,WACI,IAAIC,EAAU,IAAID,eAClBC,EAAQC,MAAMhB,UAAY,SAASM,GAE/BX,EADaW,EAAMC,OAIvBxB,EAAoB,SAASU,GACzBsB,EAAQE,MAAMrB,YAAYH,IAyC9ByB,GAEO/B,GAAO,uBAAwBA,EAAIvG,cAAc,UAvC5D,WACI,IAAIuI,EAAOhC,EAAIiC,gBACfrC,EAAoB,SAASU,GAGzB,IAAI4B,EAASlC,EAAIvG,cAAc,UAC/ByI,EAAOC,mBAAqB,WACxB3B,EAAaF,GACb4B,EAAOC,mBAAqB,KAC5BH,EAAKI,YAAYF,GACjBA,EAAS,MAEbF,EAAKK,YAAYH,IA6BrBI,GAxBA1C,EAAoB,SAASU,GACzB/B,WAAWiC,EAAc,EAAGF,IA8BpCJ,EAAS3C,aA1KT,SAAsBtF,GAEI,oBAAbA,IACTA,EAAW,IAAI+F,SAAS,GAAK/F,IAI/B,IADA,IAAIsK,EAAO,IAAIC,MAAM/D,UAAU8C,OAAS,GAC/B7J,EAAI,EAAGA,EAAI6K,EAAKhB,OAAQ7J,IAC7B6K,EAAK7K,GAAK+G,UAAU/G,EAAI,GAG5B,IAAI+K,EAAO,CAAExK,SAAUA,EAAUsK,KAAMA,GAGvC,OAFAzC,EAAcD,GAAc4C,EAC5B7C,EAAkBC,GACXA,KA6JTK,EAASR,eAAiBA,EA1J1B,SAASA,EAAeY,UACbR,EAAcQ,GAyBzB,SAASE,EAAaF,GAGlB,GAAIP,EAGAxB,WAAWiC,EAAc,EAAGF,OACzB,CACH,IAAImC,EAAO3C,EAAcQ,GACzB,GAAImC,EAAM,CACN1C,GAAwB,EACxB,KAjCZ,SAAa0C,GACT,IAAIxK,EAAWwK,EAAKxK,SAChBsK,EAAOE,EAAKF,KAChB,OAAQA,EAAKhB,QACb,KAAK,EACDtJ,IACA,MACJ,KAAK,EACDA,EAASsK,EAAK,IACd,MACJ,KAAK,EACDtK,EAASsK,EAAK,GAAIA,EAAK,IACvB,MACJ,KAAK,EACDtK,EAASsK,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAChC,MACJ,QACItK,EAAS8F,WAnDpB,EAmDqCwE,IAiBlBG,CAAID,GADR,QAGI/C,EAAeY,GACfP,GAAwB,MAvE3C,CAyLiB,qBAATlC,KAAyC,qBAAXD,EAAyB9L,KAAO8L,EAASC,Q","file":"static/js/3.382515b2.chunk.js","sourcesContent":["// @flow\n\nimport type { Node } from 'react'\n\nlet Element = 0xeac7\nlet Portal = 0xeaca\nlet Fragment = 0xeacb\nlet StrictMode = 0xeacc\nlet Profiler = 0xead2\nlet ContextProvider = 0xeacd\nlet ContextConsumer = 0xeace\nlet ConcurrentMode = 0xeacf\nlet ForwardRef = 0xead0\nlet Suspense = 0xead1\nlet Memo = 0xead3\nlet Lazy = 0xead4\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for\n  Element = symbolFor('react.element')\n  Portal = symbolFor('react.portal')\n  Fragment = symbolFor('react.fragment')\n  StrictMode = symbolFor('react.strict_mode')\n  Profiler = symbolFor('react.profiler')\n  ContextProvider = symbolFor('react.provider')\n  ContextConsumer = symbolFor('react.context')\n  ConcurrentMode = Symbol.for('react.concurrent_mode')\n  ForwardRef = symbolFor('react.forward_ref')\n  Suspense = symbolFor('react.suspense')\n  Memo = symbolFor('react.memo')\n  Lazy = symbolFor('react.lazy')\n}\n\n/** Literal types representing the ReactSymbol values. These values do not actually match the values from react-is! */\nexport type ReactSymbol =\n  | 'react.element' /* 0xeac7 | Symbol(react.element) */\n  | 'react.portal' /* 0xeaca | Symbol(react.portal) */\n  | 'react.fragment' /* 0xeacb | Symbol(react.fragment) */\n  | 'react.strict_mode' /* 0xeacc | Symbol(react.strict_mode) */\n  | 'react.profiler' /* 0xead2 | Symbol(react.profiler) */\n  | 'react.provider' /* 0xeacd | Symbol(react.provider) */\n  | 'react.context' /* 0xeace | Symbol(react.context) */\n  | 'react.concurrent_mode' /* 0xeacf | Symbol(react.concurrent_mode) */\n  | 'react.forward_ref' /* 0xead0 | Symbol(react.forward_ref) */\n  | 'react.suspense' /* 0xead1 | Symbol(react.suspense) */\n  | 'react.memo' /* 0xead3 | Symbol(react.memo) */\n  | 'react.lazy' /* 0xead4 | Symbol(react.lazy) */\n\nexport const REACT_ELEMENT_TYPE: 'react.element' = (Element: any)\nexport const REACT_PORTAL_TYPE: 'react.portal' = (Portal: any)\nexport const REACT_FRAGMENT_TYPE: 'react.fragment' = (Fragment: any)\nexport const REACT_STRICT_MODE_TYPE: 'react.strict_mode' = (StrictMode: any)\nexport const REACT_PROFILER_TYPE: 'react.profiler' = (Profiler: any)\nexport const REACT_PROVIDER_TYPE: 'react.provider' = (ContextProvider: any)\nexport const REACT_CONTEXT_TYPE: 'react.context' = (ContextConsumer: any)\nexport const REACT_CONCURRENT_MODE_TYPE: 'react.concurrent_mode' = (ConcurrentMode: any)\nexport const REACT_FORWARD_REF_TYPE: 'react.forward_ref' = (ForwardRef: any)\nexport const REACT_SUSPENSE_TYPE: 'react.suspense' = (Suspense: any)\nexport const REACT_MEMO_TYPE: 'react.memo' = (Memo: any)\nexport const REACT_LAZY_TYPE: 'react.lazy' = (Lazy: any)\n","// @flow\n\nimport { Children, type Node, type Element, type ComponentType } from 'react'\nimport type { AbstractContext, AbstractElement } from './types'\n\nimport {\n  type ReactSymbol,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE\n} from './symbols'\n\n/** Is a given Component a class component */\nexport const shouldConstruct = (Comp: ComponentType<*>): boolean %checks =>\n  (Comp: any).prototype && (Comp: any).prototype.isReactComponent\n\n/** Determine the type of element using react-is with applied fixes */\nexport const typeOf = (x: AbstractElement): ReactSymbol | void => {\n  switch (x.$$typeof) {\n    case REACT_PORTAL_TYPE:\n      return REACT_PORTAL_TYPE\n    case REACT_ELEMENT_TYPE:\n      switch (x.type) {\n        case REACT_CONCURRENT_MODE_TYPE:\n          return REACT_CONCURRENT_MODE_TYPE\n        case REACT_FRAGMENT_TYPE:\n          return REACT_FRAGMENT_TYPE\n        case REACT_PROFILER_TYPE:\n          return REACT_PROFILER_TYPE\n        case REACT_STRICT_MODE_TYPE:\n          return REACT_STRICT_MODE_TYPE\n        case REACT_SUSPENSE_TYPE:\n          return REACT_SUSPENSE_TYPE\n\n        default: {\n          switch (x.type && ((x.type: any).$$typeof: ReactSymbol)) {\n            case REACT_LAZY_TYPE:\n              return REACT_LAZY_TYPE\n            case REACT_MEMO_TYPE:\n              return REACT_MEMO_TYPE\n            case REACT_CONTEXT_TYPE:\n              return REACT_CONTEXT_TYPE\n            case REACT_PROVIDER_TYPE:\n              return REACT_PROVIDER_TYPE\n            case REACT_FORWARD_REF_TYPE:\n              return REACT_FORWARD_REF_TYPE\n            default:\n              return REACT_ELEMENT_TYPE\n          }\n        }\n      }\n\n    default:\n      return undefined\n  }\n}\n\ntype ScalarNode = null | boolean | string | number\n\n/** Rebound Children.toArray with modified AbstractElement types */\nconst toArray: (node?: Node) => Array<ScalarNode | AbstractElement> =\n  Children.toArray\n\n/** Checks whether the `node` is an AbstractElement */\nconst isAbstractElement = (\n  node: ScalarNode | AbstractElement\n): boolean %checks => node !== null && typeof node === 'object'\n\n/** Returns a flat AbstractElement array for a given AbstractElement node */\nexport const getChildrenArray = (node?: Node): AbstractElement[] => {\n  // $FlowFixMe\n  return toArray(node).filter(isAbstractElement)\n}\n\n/** Returns merged props given a props and defaultProps object */\nexport const computeProps = (props: Object, defaultProps: void | Object) => {\n  return typeof defaultProps === 'object'\n    ? Object.assign({}, defaultProps, props)\n    : props\n}\n","// @flow\n\nimport type {\n  AbstractContext,\n  UserElement,\n  ContextMap,\n  ContextStore,\n  ContextEntry\n} from '../types'\n\n/** The context is kept as a Map from a Context value to the current\n   value on the React element tree.\n   The legacy context is kept as a simple object.\n   When the tree is being walked modifications are made by assigning\n   new legacy context maps or new context values.\n   These changes are kept in the `prev` variables and must be flushed\n   before continuing to walk the tree.\n   After walking the children they can be restored.\n   This way the context recursively restores itself on the way up. */\n\nlet currentContextStore: ContextStore = new Map()\nlet currentContextMap: ContextMap = {}\n\nlet prevContextMap: void | ContextMap = undefined\nlet prevContextEntry: void | ContextEntry = undefined\n\nexport const getCurrentContextMap = (): ContextMap =>\n  Object.assign({}, currentContextMap)\nexport const getCurrentContextStore = (): ContextStore =>\n  new Map(currentContextStore)\n\nexport const flushPrevContextMap = (): void | ContextMap => {\n  const prev = prevContextMap\n  prevContextMap = undefined\n  return prev\n}\n\nexport const flushPrevContextStore = (): void | ContextEntry => {\n  const prev = prevContextEntry\n  prevContextEntry = undefined\n  return prev\n}\n\nexport const restoreContextMap = (prev: void | ContextMap) => {\n  if (prev !== undefined) {\n    Object.assign(currentContextMap, prev)\n  }\n}\n\nexport const restoreContextStore = (prev: void | ContextEntry) => {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1])\n  }\n}\n\nexport const setCurrentContextMap = (map: ContextMap) => {\n  prevContextMap = undefined\n  currentContextMap = map\n}\n\nexport const setCurrentContextStore = (store: ContextStore) => {\n  prevContextEntry = undefined\n  currentContextStore = store\n}\n\nexport const assignContextMap = (map: ContextMap) => {\n  prevContextMap = {}\n  for (const name in map) {\n    prevContextMap[name] = currentContextMap[name]\n    currentContextMap[name] = map[name]\n  }\n}\n\nexport const setContextValue = (context: AbstractContext, value: mixed) => {\n  prevContextEntry = [context, currentContextStore.get(context)]\n  currentContextStore.set(context, value)\n}\n\nexport const readContextValue = (context: AbstractContext) => {\n  const value = currentContextStore.get(context)\n  if (value !== undefined) {\n    return value\n  }\n\n  // Return default if context has no value yet\n  return context._currentValue\n}\n\nconst emptyContext = {}\n\nexport const maskContext = (type: $PropertyType<UserElement, 'type'>) => {\n  const { contextType, contextTypes } = type\n\n  if (contextType) {\n    return readContextValue(contextType)\n  } else if (!contextTypes) {\n    return emptyContext\n  }\n\n  const maskedContext = {}\n  for (const name in contextTypes) {\n    maskedContext[name] = currentContextMap[name]\n  }\n\n  return maskedContext\n}\n","// @flow\n\nimport type { ClassFrame } from '../types'\n\n/** The current error boundary frame determines where to continue rendering when an error is raised */\nlet currentErrorFrame: null | ClassFrame = null\n\nexport const getCurrentErrorFrame = (): ClassFrame | null => currentErrorFrame\n\nexport const setCurrentErrorFrame = (frame?: ClassFrame | null) => {\n  currentErrorFrame = frame || null\n}\n","// @flow\n\nimport type { RendererState } from '../types'\n\n/** The current global renderer state per render cycle */\nexport const rendererStateRef: {| current: RendererState |} = {\n  current: { uniqueID: 0 }\n}\nexport const initRendererState = (): RendererState =>\n  (rendererStateRef.current = { uniqueID: 0 })\nexport const setCurrentRendererState = (state: RendererState) =>\n  (rendererStateRef.current = state)\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  )\n}\n\nconst objectIs: (x: any, y: any) => boolean =\n  typeof Object.is === 'function' ? Object.is : is\n\nexport default objectIs\n","// @flow\n// Source: https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js\n\nimport { readContextValue } from './context'\nimport { rendererStateRef } from './state'\nimport is from './objectIs'\n\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  AbstractContext,\n  BasicStateAction,\n  Dispatch,\n  Update,\n  UpdateQueue,\n  Hook\n} from '../types'\n\nexport opaque type Identity = {}\nexport opaque type OpaqueIDType = string\n\nlet currentIdentity: Identity | null = null\n\nexport const makeIdentity = (): Identity => ({})\n\nexport const setCurrentIdentity = (id: Identity | null) => {\n  currentIdentity = id\n}\n\nexport const getCurrentIdentity = (): Identity => {\n  if (currentIdentity === null) {\n    throw new Error(\n      '[react-ssr-prepass] Hooks can only be called inside the body of a function component. ' +\n        '(https://fb.me/react-invalid-hook-call)'\n    )\n  }\n\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L63-L71\n\n  return (currentIdentity: Identity)\n}\n\nlet firstWorkInProgressHook: Hook | null = null\nlet workInProgressHook: Hook | null = null\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<UpdateQueue<any>, Update<any>> | null = null\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0\nconst RE_RENDER_LIMIT = 25\n\nexport const getFirstHook = (): Hook | null => firstWorkInProgressHook\n\nexport const setFirstHook = (hook: Hook | null) => {\n  firstWorkInProgressHook = hook\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null\n) {\n  // NOTE: The warnings that are used in ReactPartialRendererHooks are obsolete\n  // in a prepass, since these issues will be caught by a subsequent renderer anyway\n  if (prevDeps === null) return false\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is(nextDeps[i], prevDeps[i])) return false\n  }\n\n  return true\n}\n\nfunction createHook(): Hook {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  }\n}\n\nfunction createWorkInProgressHook(): Hook {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      return (firstWorkInProgressHook = workInProgressHook = createHook())\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      return (workInProgressHook = firstWorkInProgressHook)\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      // Append to the end of the list\n      return (workInProgressHook = workInProgressHook.next = createHook())\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      return (workInProgressHook = workInProgressHook.next)\n    }\n  }\n}\n\nexport function renderWithHooks(\n  Component: any,\n  props: any,\n  refOrContext: any\n): any {\n  workInProgressHook = null\n  let children = Component(props, refOrContext)\n\n  // NOTE: Excessive rerenders won't throw but will instead abort rendering\n  // since a subsequent renderer can throw when this issue occurs instead\n  while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {\n    // Updates were scheduled during the render phase. They are stored in\n    // the `renderPhaseUpdates` map. Call the component again, reusing the\n    // work-in-progress hooks and applying the additional updates on top. Keep\n    // restarting until no more updates are scheduled.\n    didScheduleRenderPhaseUpdate = false\n    numberOfReRenders += 1\n    // Start over from the beginning of the list\n    workInProgressHook = null\n    children = Component(props, refOrContext)\n  }\n\n  // This will be reset by renderer\n  // firstWorkInProgressHook = null\n\n  numberOfReRenders = 0\n  renderPhaseUpdates = null\n  workInProgressHook = null\n\n  return children\n}\n\nfunction readContext(context: AbstractContext, _: void | number | boolean) {\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L215-L223\n  return readContextValue(context)\n}\n\nfunction useContext(context: AbstractContext, _: void | number | boolean) {\n  getCurrentIdentity()\n  return readContextValue(context)\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe\n  return typeof action === 'function' ? action(state) : action\n}\n\nfunction useState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any)\n  )\n}\n\nfunction useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  const id = getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  // In the case of a re-render after a suspense, the initial state\n  // may not be set, so instead of initialising if `!isRerender`, we\n  // check whether `queue` is set\n  if (workInProgressHook.queue === null) {\n    let initialState\n    if (reducer === basicStateReducer) {\n      // Special case for `useState`.\n      initialState =\n        typeof initialArg === 'function'\n          ? ((initialArg: any): () => S)()\n          : ((initialArg: any): S)\n    } else {\n      initialState =\n        init !== undefined ? init(initialArg) : ((initialArg: any): S)\n    }\n\n    workInProgressHook.memoizedState = initialState\n  }\n\n  const queue: UpdateQueue<A> =\n    workInProgressHook.queue ||\n    (workInProgressHook.queue = { last: null, dispatch: null })\n  const dispatch: Dispatch<A> =\n    queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue))\n\n  if (renderPhaseUpdates !== null) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // current hook.\n    // Render phase updates are stored in a map of queue -> linked list\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate !== undefined) {\n      renderPhaseUpdates.delete(queue)\n      let newState = workInProgressHook.memoizedState\n      let update = firstRenderPhaseUpdate\n      do {\n        // Process this render phase update. We don't have to check the\n        // priority because it will always be the same as the current\n        // render's.\n        const action = update.action\n        newState = reducer(newState, action)\n        update = update.next\n      } while (update !== null)\n\n      workInProgressHook.memoizedState = newState\n    }\n  }\n\n  return [workInProgressHook.memoizedState, dispatch]\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  const nextDeps = deps === undefined ? null : deps\n  const prevState = workInProgressHook.memoizedState\n  if (prevState !== null && nextDeps !== null) {\n    const prevDeps = prevState[1]\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0]\n    }\n  }\n\n  const nextValue = nextCreate()\n  workInProgressHook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n\nfunction useRef<T>(initialValue: T): { current: T } {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  const previousRef = workInProgressHook.memoizedState\n  if (previousRef === null) {\n    const ref = { current: initialValue }\n    workInProgressHook.memoizedState = ref\n    return ref\n  } else {\n    return previousRef\n  }\n}\n\nfunction useOpaqueIdentifier(): OpaqueIDType {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  if (!workInProgressHook.memoizedState)\n    workInProgressHook.memoizedState =\n      'R:' + (rendererStateRef.current.uniqueID++).toString(36)\n  return workInProgressHook.memoizedState\n}\n\nfunction dispatchAction<A>(\n  componentIdentity: Identity,\n  queue: UpdateQueue<A>,\n  action: A\n) {\n  if (componentIdentity === currentIdentity) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true\n    const update: Update<A> = {\n      action,\n      next: null\n    }\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map()\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update)\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next\n      }\n      lastRenderPhaseUpdate.next = update\n    }\n  } else {\n    // This means an update has happened after the function component has\n    // returned. On the server this is a no-op. In React Fiber, the update\n    // would be scheduled for a future render.\n  }\n}\n\nfunction useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  return useMemo(() => callback, deps)\n}\n\nfunction useMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  _subscribe: MutableSourceSubscribeFn<Source, Snapshot>\n): Snapshot {\n  getCurrentIdentity()\n  return getSnapshot(source._source)\n}\n\nfunction noop(): void {}\n\nfunction useTransition(): [(callback: () => void) => void, boolean] {\n  const startTransition = (callback) => {\n    callback()\n  }\n  return [startTransition, false]\n}\n\nfunction useDeferredValue<T>(input: T): T {\n  return input\n}\n\nexport const Dispatcher = {\n  readContext,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useCallback,\n  useMutableSource,\n  useTransition,\n  useDeferredValue,\n  useOpaqueIdentifier,\n  // ignore useLayout effect completely as usage of it will be caught\n  // in a subsequent render pass\n  useLayoutEffect: noop,\n  // useImperativeHandle is not run in the server environment\n  useImperativeHandle: noop,\n  // Effects are not run in the server environment.\n  useEffect: noop,\n  // Debugging effect\n  useDebugValue: noop\n}\n","// @flow\n\nimport { createElement, type Node } from 'react'\nimport type {\n  LazyComponent,\n  LazyComponentPayload,\n  DefaultProps,\n  LazyFrame,\n  Frame\n} from '../types'\nimport { getChildrenArray } from '../element'\n\nimport {\n  setCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame\n} from '../internals'\n\nconst resolve = (type: LazyComponent): Promise<void> => {\n  const payload = (type._payload || type: any)\n  if (payload._status === 0) {\n    return payload._result\n  } else if (payload._status === 1) {\n    return Promise.resolve(payload._result)\n  } else if (payload._status === 2) {\n    return Promise.reject(payload._result)\n  }\n\n  payload._status = 0 /* PENDING */\n\n  return (payload._result = (payload._ctor || payload._result)()\n    .then((Component) => {\n      payload._result = Component\n      if (typeof Component === 'function') {\n        payload._status = 1 /* SUCCESSFUL */\n      } else if (\n        Component !== null &&\n        typeof Component === 'object' &&\n        typeof Component.default === 'function'\n      ) {\n        payload._result = Component.default\n        payload._status = 1 /* SUCCESSFUL */\n      } else {\n        payload._status = 2 /* FAILED */\n      }\n    })\n    .catch((error) => {\n      payload._status = 2 /* FAILED */\n      payload._result = error\n      return Promise.reject(error)\n    }))\n}\n\nconst render = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // Component has previously been fetched successfully,\n  // so create the element with passed props and return it\n  const payload = ((type._payload || type: any): LazyComponentPayload)\n  if (payload._status === 1) {\n    return createElement(payload._result, props)\n  }\n\n  return null\n}\n\nexport const mount = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // If the component has not been fetched yet, suspend this component\n  const payload = ((type._payload || type: any): LazyComponentPayload)\n  if (payload._status <= 0) {\n    queue.push({\n      kind: 'frame.lazy',\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      errorFrame: getCurrentErrorFrame(),\n      thenable: resolve(type),\n      props,\n      type\n    })\n\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\nexport const update = (queue: Frame[], frame: LazyFrame): Node => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Hook,\n  Frame,\n  HooksFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  type Identity,\n  maskContext,\n  makeIdentity,\n  setCurrentIdentity,\n  getCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  renderWithHooks,\n  setFirstHook,\n  getFirstHook\n} from '../internals'\n\nconst makeFrame = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  thenable: Promise<any>\n) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  id: getCurrentIdentity(),\n  hook: getFirstHook(),\n  kind: 'frame.hooks',\n  errorFrame: getCurrentErrorFrame(),\n  thenable,\n  props,\n  type\n})\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  try {\n    return renderWithHooks(\n      type,\n      computeProps(props, type.defaultProps),\n      maskContext(type)\n    )\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      throw error\n    }\n\n    queue.push(makeFrame(type, props, error))\n    return null\n  }\n}\n\n/** Mount a function component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n): Node => {\n  setFirstHook(null)\n  setCurrentIdentity(makeIdentity())\n\n  const promise = visitor(element)\n  if (promise) {\n    queue.push(makeFrame(type, props, promise))\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\n/** Update a previously suspended function component */\nexport const update = (queue: Frame[], frame: HooksFrame) => {\n  setFirstHook(frame.hook)\n  setCurrentIdentity(frame.id)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Frame,\n  ClassFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  maskContext,\n  assignContextMap,\n  setCurrentIdentity,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame\n} from '../internals'\n\nconst RE_RENDER_LIMIT = 25\n\nconst createUpdater = () => {\n  const queue = []\n\n  return {\n    _thrown: 0,\n    queue,\n    isMounted: () => false,\n    enqueueForceUpdate: () => null,\n    enqueueReplaceState: (instance, completeState) => {\n      if (instance._isMounted) {\n        queue.length = 0\n        queue.push(completeState)\n      }\n    },\n    enqueueSetState: (instance, currentPartialState) => {\n      if (instance._isMounted) {\n        queue.push(currentPartialState)\n      }\n    }\n  }\n}\n\nconst flushEnqueuedState = (instance: any) => {\n  const queue = (instance.updater.queue: any[])\n\n  if (queue.length > 0) {\n    let nextState = Object.assign({}, instance.state)\n\n    for (let i = 0, l = queue.length; i < l; i++) {\n      const partial = queue[i]\n      const partialState =\n        typeof partial === 'function'\n          ? partial.call(instance, nextState, instance.props, instance.context)\n          : partial\n      if (partialState !== null) {\n        Object.assign(nextState, partialState)\n      }\n    }\n\n    instance.state = nextState\n    queue.length = 0\n  }\n}\n\nconst createInstance = (type: any, props: DefaultProps) => {\n  const updater = createUpdater()\n  const computedProps = computeProps(props, type.defaultProps)\n  const context = maskContext(type)\n  const instance = new type(computedProps, context, updater)\n\n  instance.props = computedProps\n  instance.context = context\n  instance.updater = updater\n  instance._isMounted = true\n\n  if (instance.state === undefined) {\n    instance.state = null\n  }\n\n  if (\n    typeof instance.componentDidCatch === 'function' ||\n    typeof type.getDerivedStateFromError === 'function'\n  ) {\n    const frame = makeFrame(type, instance, null)\n    frame.errorFrame = frame\n    setCurrentErrorFrame(frame)\n  }\n\n  if (typeof type.getDerivedStateFromProps === 'function') {\n    const { getDerivedStateFromProps } = type\n    const state = getDerivedStateFromProps(instance.props, instance.state)\n    if (state !== null && state !== undefined) {\n      instance.state = Object.assign({}, instance.state, state)\n    }\n  } else if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount()\n  } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount()\n  }\n\n  return instance\n}\n\nconst makeFrame = (\n  type: any,\n  instance: any,\n  thenable: Promise<any> | null\n) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  errorFrame: getCurrentErrorFrame(),\n  thenable,\n  kind: 'frame.class',\n  error: null,\n  instance,\n  type\n})\n\nconst render = (type: any, instance: any, queue: Frame[]) => {\n  // Flush all queued up state changes\n  flushEnqueuedState(instance)\n  let child: Node = null\n\n  try {\n    child = instance.render()\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      throw error\n    }\n\n    queue.push(makeFrame(type, instance, error))\n    return null\n  }\n\n  if (\n    type.childContextTypes !== undefined &&\n    typeof instance.getChildContext === 'function'\n  ) {\n    const childContext = instance.getChildContext()\n    if (childContext !== null && typeof childContext === 'object') {\n      assignContextMap(childContext)\n    }\n  }\n\n  if (\n    typeof instance.getDerivedStateFromProps !== 'function' &&\n    (typeof instance.componentWillMount === 'function' ||\n      typeof instance.UNSAFE_componentWillMount === 'function') &&\n    typeof instance.componentWillUnmount === 'function'\n  ) {\n    try {\n      instance.componentWillUnmount()\n    } catch (_err) {}\n  }\n\n  instance._isMounted = false\n  return child\n}\n\n/** Mount a class component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n) => {\n  setCurrentIdentity(null)\n\n  const instance = createInstance(type, props)\n  const promise = visitor(element, instance)\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise))\n    return null\n  }\n\n  return render(type, instance, queue)\n}\n\n/** Update a previously suspended class component */\nexport const update = (queue: Frame[], frame: ClassFrame) => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n\n  if (frame.error) {\n    // We simply have to bail when a loop occurs\n    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) return null\n\n    frame.instance._isMounted = true\n\n    if (typeof frame.instance.componentDidCatch === 'function') {\n      frame.instance.componentDidCatch(frame.error)\n    }\n\n    if (typeof frame.type.getDerivedStateFromError === 'function') {\n      frame.instance.updater.enqueueSetState(\n        frame.instance,\n        frame.type.getDerivedStateFromError(frame.error)\n      )\n    }\n  }\n\n  return render(frame.type, frame.instance, queue)\n}\n","// @flow\n\nimport React, { type Node, type ComponentType, createElement } from 'react'\n\nimport {\n  typeOf,\n  shouldConstruct,\n  getChildrenArray,\n  computeProps\n} from './element'\n\nimport {\n  mountFunctionComponent,\n  updateFunctionComponent,\n  mountClassComponent,\n  updateClassComponent,\n  mountLazyComponent,\n  updateLazyComponent\n} from './render'\n\nimport type {\n  Visitor,\n  YieldFrame,\n  ClassFrame,\n  Frame,\n  ContextMap,\n  ContextEntry,\n  DefaultProps,\n  ComponentStatics,\n  LazyElement,\n  AbstractElement,\n  ConsumerElement,\n  ProviderElement,\n  FragmentElement,\n  SuspenseElement,\n  ForwardRefElement,\n  MemoElement,\n  UserElement,\n  DOMElement\n} from './types'\n\nimport {\n  getCurrentContextMap,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  setCurrentContextStore,\n  flushPrevContextMap,\n  flushPrevContextStore,\n  restoreContextMap,\n  restoreContextStore,\n  readContextValue,\n  setContextValue,\n  setCurrentIdentity,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  Dispatcher\n} from './internals'\n\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE\n} from './symbols'\n\nconst {\n  ReactCurrentDispatcher\n} = (React: any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\n// In the presence of setImmediate, i.e. on Node, we'll enable the\n// yielding behavior that gives the event loop a chance to continue\n// running when the prepasses would otherwise take too long\nexport const SHOULD_YIELD = typeof setImmediate === 'function'\n// Time in ms after which the otherwise synchronous visitor yields so that\n// the event loop is not interrupted for too long\nconst YIELD_AFTER_MS = 5\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n) => {\n  return shouldConstruct(type)\n    ? mountClassComponent(type, props, queue, visitor, element)\n    : mountFunctionComponent(type, props, queue, visitor, element)\n}\n\nexport const visitElement = (\n  element: AbstractElement,\n  queue: Frame[],\n  visitor: Visitor\n): AbstractElement[] => {\n  switch (typeOf(element)) {\n    case REACT_SUSPENSE_TYPE:\n    case REACT_STRICT_MODE_TYPE:\n    case REACT_CONCURRENT_MODE_TYPE:\n    case REACT_PROFILER_TYPE:\n    case REACT_FRAGMENT_TYPE: {\n      // These element types are simply traversed over but otherwise ignored\n      const fragmentElement = ((element: any):\n        | FragmentElement\n        | SuspenseElement)\n      return getChildrenArray(fragmentElement.props.children)\n    }\n\n    case REACT_PROVIDER_TYPE: {\n      const providerElement = ((element: any): ProviderElement)\n      // Add provider's value prop to context\n      const { value, children } = providerElement.props\n      setContextValue(providerElement.type._context, value)\n\n      return getChildrenArray(children)\n    }\n\n    case REACT_CONTEXT_TYPE: {\n      const consumerElement = ((element: any): ConsumerElement)\n      const { children } = consumerElement.props\n\n      // Read from context and call children, if it's been passed\n      if (typeof children === 'function') {\n        const type = (consumerElement.type: any)\n        const context = typeof type._context === 'object' ? type._context : type\n        const value = readContextValue(context)\n        return getChildrenArray(children(value))\n      } else {\n        return []\n      }\n    }\n\n    case REACT_LAZY_TYPE: {\n      const lazyElement = ((element: any): LazyElement)\n      const type = lazyElement.type\n      const child = mountLazyComponent(type, lazyElement.props, queue)\n      return getChildrenArray(child)\n    }\n\n    case REACT_MEMO_TYPE: {\n      const memoElement = ((element: any): MemoElement)\n      const { type } = memoElement.type\n      const child = createElement((type: any), memoElement.props)\n      return getChildrenArray(child)\n    }\n\n    case REACT_FORWARD_REF_TYPE: {\n      const refElement = ((element: any): ForwardRefElement)\n      const { render: type, defaultProps } = refElement.type\n      const props = computeProps(refElement.props, defaultProps)\n      const child = createElement((type: any), props)\n      return getChildrenArray(child)\n    }\n\n    case REACT_ELEMENT_TYPE: {\n      const el = ((element: any): UserElement | DOMElement)\n      if (typeof el.type === 'string') {\n        // String elements can be skipped, so we just return children\n        return getChildrenArray(el.props.children)\n      } else {\n        const userElement = ((element: any): UserElement)\n        const { type, props } = userElement\n        const child = render(type, props, queue, visitor, userElement)\n        return getChildrenArray(child)\n      }\n    }\n\n    case REACT_PORTAL_TYPE:\n    // Portals are unsupported during SSR since they're DOM-only\n    default:\n      return []\n  }\n}\n\nconst visitLoop = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>,\n  traversalErrorFrame: Array<null | ClassFrame>,\n  queue: Frame[],\n  visitor: Visitor\n): boolean => {\n  const prevDispatcher = ReactCurrentDispatcher.current\n  const start = Date.now()\n\n  try {\n    ReactCurrentDispatcher.current = Dispatcher\n    while (traversalChildren.length > 0) {\n      const element = traversalChildren[traversalChildren.length - 1].shift()\n      if (element !== undefined) {\n        const children = visitElement(element, queue, visitor)\n        traversalChildren.push(children)\n        traversalMap.push(flushPrevContextMap())\n        traversalStore.push(flushPrevContextStore())\n        traversalErrorFrame.push(getCurrentErrorFrame())\n      } else {\n        traversalChildren.pop()\n        restoreContextMap(traversalMap.pop())\n        restoreContextStore(traversalStore.pop())\n        setCurrentErrorFrame(traversalErrorFrame.pop())\n      }\n\n      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {\n        return true\n      }\n    }\n\n    return false\n  } catch (error) {\n    const errorFrame = getCurrentErrorFrame()\n    if (!errorFrame) throw error\n    errorFrame.error = error\n    queue.unshift(errorFrame)\n    return false\n  } finally {\n    ReactCurrentDispatcher.current = prevDispatcher\n  }\n}\n\nconst makeYieldFrame = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>,\n  traversalErrorFrame: Array<null | ClassFrame>\n): Frame => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  errorFrame: getCurrentErrorFrame(),\n  thenable: null,\n  kind: 'frame.yield',\n  traversalChildren,\n  traversalMap,\n  traversalStore,\n  traversalErrorFrame\n})\n\nexport const visit = (\n  init: AbstractElement[],\n  queue: Frame[],\n  visitor: Visitor\n) => {\n  const traversalChildren: AbstractElement[][] = [init]\n  const traversalMap: Array<void | ContextMap> = [flushPrevContextMap()]\n  const traversalStore: Array<void | ContextEntry> = [flushPrevContextStore()]\n  const traversalErrorFrame: Array<null | ClassFrame> = [getCurrentErrorFrame()]\n\n  const hasYielded = visitLoop(\n    traversalChildren,\n    traversalMap,\n    traversalStore,\n    traversalErrorFrame,\n    queue,\n    visitor\n  )\n\n  if (hasYielded) {\n    queue.unshift(\n      makeYieldFrame(\n        traversalChildren,\n        traversalMap,\n        traversalStore,\n        traversalErrorFrame\n      )\n    )\n  }\n}\n\nexport const update = (frame: Frame, queue: Frame[], visitor: Visitor) => {\n  if (frame.kind === 'frame.yield') {\n    setCurrentIdentity(null)\n    setCurrentContextMap(frame.contextMap)\n    setCurrentContextStore(frame.contextStore)\n    setCurrentErrorFrame(frame.errorFrame)\n\n    const hasYielded = visitLoop(\n      frame.traversalChildren,\n      frame.traversalMap,\n      frame.traversalStore,\n      frame.traversalErrorFrame,\n      queue,\n      visitor\n    )\n\n    if (hasYielded) {\n      queue.unshift(\n        makeYieldFrame(\n          frame.traversalChildren,\n          frame.traversalMap,\n          frame.traversalStore,\n          frame.traversalErrorFrame\n        )\n      )\n    }\n  } else {\n    const prevDispatcher = ReactCurrentDispatcher.current\n    let children = null\n\n    ReactCurrentDispatcher.current = Dispatcher\n\n    try {\n      if (frame.kind === 'frame.class') {\n        children = updateClassComponent(queue, frame)\n      } else if (frame.kind === 'frame.hooks') {\n        children = updateFunctionComponent(queue, frame)\n      } else if (frame.kind === 'frame.lazy') {\n        children = updateLazyComponent(queue, frame)\n      }\n    } catch (error) {\n      const errorFrame = getCurrentErrorFrame()\n      if (!errorFrame) throw error\n      errorFrame.error = error\n      queue.unshift(errorFrame)\n      children = null\n    } finally {\n      ReactCurrentDispatcher.current = prevDispatcher\n    }\n\n    visit(getChildrenArray(children), queue, visitor)\n  }\n}\n","// @flow\n\nimport { type Node, type Element } from 'react'\nimport type {\n  Visitor,\n  YieldFrame,\n  Frame,\n  AbstractElement,\n  RendererState\n} from './types'\nimport { visit, update, SHOULD_YIELD } from './visitor'\nimport { getChildrenArray } from './element'\n\nimport {\n  setCurrentContextStore,\n  setCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  setCurrentRendererState,\n  initRendererState,\n  Dispatcher\n} from './internals'\n\n/** visit() walks all elements (depth-first) and while it walks the\n    element tree some components will suspend and put a `Frame` onto\n    the queue. Hence we recursively look at suspended components in\n    this queue, wait for their promises to resolve, and continue\n    calling visit() on their children. */\nconst flushFrames = (\n  queue: Frame[],\n  visitor: Visitor,\n  state: RendererState\n): Promise<void> => {\n  const frame = queue.shift()\n  if (!frame) {\n    return Promise.resolve()\n  }\n\n  if (SHOULD_YIELD && frame.kind === 'frame.yield') {\n    frame.thenable = new Promise((resolve, reject) => {\n      setImmediate(resolve)\n    })\n  }\n\n  return Promise.resolve(frame.thenable).then(\n    () => {\n      setCurrentRendererState(state)\n      update(frame, queue, visitor)\n      return flushFrames(queue, visitor, state)\n    },\n    (error: Error) => {\n      if (!frame.errorFrame) throw error\n      frame.errorFrame.error = error\n      update(frame.errorFrame, queue, visitor)\n    }\n  )\n}\n\nconst defaultVisitor = () => undefined\n\nconst renderPrepass = (element: Node, visitor?: Visitor): Promise<void> => {\n  if (!visitor) visitor = defaultVisitor\n\n  const queue: Frame[] = []\n  // Renderer state is kept globally but restored and\n  // passed around manually since it isn't dependent on the\n  // render tree\n  const state = initRendererState()\n  // Context state is kept globally and is modified in-place.\n  // Before we start walking the element tree we need to reset\n  // its current state\n  setCurrentContextMap({})\n  setCurrentContextStore(new Map())\n  setCurrentErrorFrame(null)\n\n  try {\n    visit(getChildrenArray(element), queue, visitor)\n  } catch (error) {\n    return Promise.reject(error)\n  }\n\n  return flushFrames(queue, visitor, state)\n}\n\nexport default renderPrepass\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n"],"sourceRoot":""}